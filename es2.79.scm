(define (equ? x y)
  (apply-generic 'equ x y))
(define (install-equ)
  ; equal types
  (put 'equ '(scheme-number scheme-number)
    (lambda (x y) (= x y)))
  (put 'equ '(rational rational)
    (lambda (x y) (equ-rat? x y)))
  (put 'equ '(complex complex)
    (lambda (x y) (equ-complex? x y)))
  ; different types
  (put 'equ '(scheme-number rational)
    (lambda (x y) (equ? (make-rat x 1) y)))
  (put 'equ '(scheme-number complex)
    (lambda (x y) (equ? (make-complex x 0) y)))
  (put 'equ '(rational complex)
    ; warning: possible loss of precision
    (lambda (x y) (equ? (make-complex (/ (numer x)
                                         (denom x))
                                      0)
                        y)))
  ; just the reverse order of different types wrt before
  (put 'equ '(rational scheme-number)
    (lambda (x y) (equ? y x)))
  (put 'equ '(complex scheme-number)
    (lambda (x y) (equ? y x)))
  (put 'equ '(complex rational)
    (lambda (x y) (equ? y x)))
  'done)
