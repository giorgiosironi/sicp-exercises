; element of a doubly-linked list
(define (make-element value)
  (cons value (cons '() '())))
(define (value element)
  (car element))
(define (pointers element)
  (cdr element))
(define (left element)
  (car (pointers element)))
(define (right element)
  (cdr (pointers element)))
(define (set-left! element pointer)
  (set-car! (pointers element) pointer))
(define (set-right! element pointer)
  (set-cdr! (pointers element) pointer))
(define (single-linked-list-from-left element)
  (if (null? element)
      '()
      (cons (value element)
            (single-linked-list-from-left (right element)))))

; deque implementation
(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-deque?) (null? front-ptr))
    (define (front-deque)
      (if (empty-deque?)
        (error "FRONT called with an empty deque")
        (value front-ptr)))
    (define (rear-deque)
      (if (empty-deque?)
        (error "REAR called with an empty deque")
        (value rear-ptr)))
    (define (front-insert-deque! item)
      (let ((new-element (make-element item)))
        (cond ((empty-deque?)
                 (set! front-ptr new-element)
                 (set! rear-ptr new-element))
              (else
                (set-left! front-ptr new-element)
                (set-right! new-element front-ptr)
                (set! front-ptr new-element))))
      dispatch)
    (define (rear-insert-deque! item)
      (let ((new-element (make-element item)))
        (cond ((empty-deque?)
                 (set! front-ptr new-element)
                 (set! rear-ptr new-element))
              (else
                (set-right! rear-ptr new-element)
                (set-left! new-element rear-ptr)
                (set! rear-ptr new-element))))
      dispatch)
    (define (front-delete-deque!)
      (cond ((empty-deque?)
             (error "FRONT-DELETE on empty deque"))
            (else
             (set! front-ptr (right front-ptr))
             (if (null? front-ptr)
                 (set! rear-ptr '())
                 (set-left! front-ptr '()))))
      dispatch)
    (define (rear-delete-deque!)
      (cond ((empty-deque?)
             (error "FRONT-DELETE on empty deque"))
            (else
             (set! rear-ptr (left rear-ptr))
             (if (null? rear-ptr)
                 (set! front-ptr '())
                 (set-right! rear-ptr '()))))
      dispatch)
    ; review from here on
    (define (print-deque)
      (single-linked-list-from-left front-ptr))
    (define (dispatch m)
      (cond ((eq? m 'empty-deque?) empty-deque?)
            ((eq? m 'front-deque) front-deque)
            ((eq? m 'rear-deque) rear-deque)
            ((eq? m 'front-insert-deque!) front-insert-deque!)
            ((eq? m 'rear-insert-deque!) rear-insert-deque!)
            ((eq? m 'front-delete-deque!) front-delete-deque!)
            ((eq? m 'rear-delete-deque!) rear-delete-deque!)
            ((eq? m 'print-deque) print-deque)
            (else (error "Unknown operation -- MAKE-deque"))))
    dispatch))

; sample data
(define q1 (make-deque))
((q1 'rear-insert-deque!) 'a)
((q1 'rear-insert-deque!) 'b)
((q1 'front-delete-deque!))
((q1 'front-delete-deque!))
((q1 'front-insert-deque!) 'd)
((q1 'front-insert-deque!) 'c)
