; library
(define (enclosing-environment env) (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
    (cons (make-frame vars vals) base-env)
    (if (< (length vars) (length vals))
      (error "Too many arguments supplied" vars vals)
      (error "Too few arguments supplied" vars vals))))
(define (make-binding var val)
  (cons var val))
(define (binding-var binding)
  (car binding))
(define (binding-val binding)
  (cdr binding))
(define (binding-set! binding val)
  (set-cdr! binding val))
(define (make-frame variables values)
  (cons 'frame (map make-binding variables values)))
(define (frame-bindings frame)
  (cdr frame))
(define (make-let vars exps body)
  (cons 'let
        (cons (make-let-bindings vars exps)
              body)))
(define (make-let-bindings vars exps)
  (map (lambda (var exp)
         (list var exp))
       vars
       exps))
; exercise
(define (lookup-variable-value var env)
  (define (env-loop env)
    (define (scan bindings)
      (cond ((null? bindings)
             (env-loop (enclosing-environment env)))
            ((eq? var (binding-var (car bindings)))
             (let ((val (binding-val (car bindings))))
               (if (eq? val '*unassigned)
                   (error "UNASSIGNED VALUE" var)
                   val)))
            (else (scan (cdr bindings)))))
    (if (eq? env the-empty-environment)
      (error "Unbound variable" var)
      (begin 
        (display "Env: ") (display env) (newline)
        (let ((frame (first-frame env)))
          (display "Frame: ") (display frame) (newline)
          (scan (frame-bindings frame))))))
  (display "Lookup: ") (display var) (newline)
  (env-loop env))
(define an-environment (extend-environment '(foo) '(*unassigned) the-empty-environment))
(define (scan-out-defines procedure-body)
  (define (new-body names values remaining-body)
    (make-let names 
              (map (lambda (names) '*unassigned)
                   names)
              (append
                (map (lambda (name value)
                       (list 'set! name value))
                     names
                     values)
                remaining-body)))
  (define (iter-scan-out procedure-body names values executable-body)
    (if (null? procedure-body)
        (new-body names values executable-body)
        (let ((expression (car procedure-body)))
          (if (define? expression)
              (iter-scan-out (cdr procedure-body)
                             (cons (define-name expression)
                                   names)
                             (cons (define-value expression)
                                   values)
                             executable-body)
              (iter-scan-out (cdr procedure-body)
                             names
                             values
                             (append executable-body
                                     (list expression)))))))
  (iter-scan-out procedure-body '() '() '()))
(define (define? expression)
  (and (pair? expression)
       (eq? 'define (car expression))))
(define (define-name expression)
  (cadr expression))
(define (define-value expression)
  (caddr expression))
(define sample-body '((define u 41) (define v 42) 43))
; I think make-procedure is better than procedure-body because this transformation is only performed once at compile-time
(define (make-procedure parameters body env)
  (list 'procedure parameters (scan-out-defines body) env))
