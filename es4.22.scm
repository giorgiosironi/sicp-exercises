; library
(define (make-frame variables values)
  (cons variables values))
(define (frame-variables frame) (car frame))
(define (frame-values frame) (cdr frame))
(define (add-binding-to-frame! var val frame)
  (set-car! frame (cons var (car frame)))
  (set-cdr! frame (cons val (cdr frame))))
(define (extend-environment vars vals base-env)
  (if (= (length vars) (length vals))
    (cons (make-frame vars vals) base-env)
    (if (< (length vars) (length vals))
      (error "Too many arguments supplied" vars vals)
      (error "Too few arguments supplied" vars vals))))
(define (tagged-list? exp tag)
  (if (pair? exp)
    (eq? (car exp) tag)
    false))
(define (operator exp) (car exp))
(define (operands exp) (cdr exp))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
(define (make-application proc parameters)
  (cons proc parameters))
(define (let-vars exp)
  (map (lambda (binding) (car binding))
       (cadr exp)))
(define (let-exps exp)
  (map (lambda (binding) (cadr binding))
       (cadr exp)))
(define (let-body exp)
  (cddr exp))
(define (lambda-parameters exp) (cadr exp))
(define (lambda-body exp) (cddr exp))
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p) (cadr p))
(define (procedure-body p) (caddr p))
(define (procedure-environment p) (cadddr p))
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
      first-proc
      (loop (sequentially first-proc (car rest-procs))
            (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
      (error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))
(define (analyze-application exp)
  ; modified fproc, only supports lambda
  (let ((fproc (analyze-lambda (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application (fproc env)
                           (map (lambda (aproc) (aproc env))
                                aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
         (apply-primitive-procedure proc args))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))))
        (else
          (error
            "Unknown procedure type -- EXECUTE-APPLICATION"
            proc))))
; exercise
; not wanting to paste in the library section the full analyze procedure,
; I define here a very basic one which will support just this example
(define (analyze exp)
  (lambda (env) exp))
(define (let->combination exp)
  (analyze-application (make-application (make-lambda (let-vars exp)
                                                      (let-body exp))
                                         (let-exps exp))))
;(display 
;  ((let->combination '(let ((x 3) (y 2)) (+ x y)))
;   '()))
;(newline)
