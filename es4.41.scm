(define (flatmap proc seq)
  (apply append (map proc seq)))
(define (remove item seq)
  (if (null? seq)
      '()
      (if (equal? item (car seq))
          (cdr seq)
          (cons (car seq) (remove item (cdr seq))))))
(define (permutations elements)
  (if (null? elements)
      '(())
      (flatmap (lambda (e)
                 (map (lambda (subpermutation)
                        (cons e subpermutation))
                      (permutations (remove e elements))))
               elements)))
; 0-based
(define (nth n seq)
  (if (>= n (length seq))
      (error "-- NTH out of bounds" n seq)
      (car (drop seq n))))
(define (multiple-dwelling)
  (let ((floors (permutations '(1 2 3 4 5))))
    (let ((solutions
            (filter (lambda (candidate)
                      (let ((baker (nth 0 candidate))
                            (cooper (nth 1 candidate))
                            (fletcher (nth 2 candidate))
                            (miller (nth 3 candidate))
                            (smith (nth 4 candidate)))
                        (and (not (= baker 5))
                             (not (= cooper 1))
                             (not (= fletcher 5))
                             (not (= fletcher 1))
                             (> miller cooper)
                             (not (= (abs (- smith fletcher)) 1))
                             (not (= (abs (- fletcher cooper)) 1)))))
                    floors)))
      (map (lambda (solution)
             (list (list 'baker (nth 0 solution))
                   (list 'cooper (nth 1 solution))
                   (list 'fletcher (nth 2 solution))
                   (list 'miller (nth 3 solution))
                   (list 'smith (nth 4 solution))))
           solutions))))
(display (multiple-dwelling))
